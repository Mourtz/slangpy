Your First Function
===================

In this simple example we're going to initial SGL, create a simple slang function, and 
call it from Python.

First let's create a simple slang function to add 2 numbers together.

.. code-block::
    
    ## example.slang

    // A simple function that adds two numbers together
    float add(float a, float b)
    {
        return a + b;
    }

Now create a simple Python script that starts up SGL, loads the slang module and 
calls the function.

.. code-block:: python

    ## main.py

    import sgl
    import slangpy as spy
    import numpy as np

    # Create an SGL device
    device = sgl.Device()

    # Create a simple function
    module = spy.Module(device, "example.slang")

    # Call the function and print the result
    result = module.add(1.0,2.0)
    print(result)

    # Create some data
    a = np.array([1.0, 2.0, 3.0, 4.0, 5.0], dtype=np.float32)
    b = np.array([10.0, 20.0, 30.0, 40.0, 50.0], dtype=np.float32)

    # Call our function and ask for a numpy array back (the default would be a buffer)
    result = module.add(a, b, return='numpy')
    print(result)

Under the hood, the first time the function is invoked SlangPy will generate a compute kernel 
(and save a copy to a .temp folder) that loads the scalar inputs from buffers, calls the 
``add`` function and writes the scalar result back to a buffer. 

This is fun, but obviously not particularly useful or efficient. Dispatching a compute kernel 
just to add 2 numbers together is a bit overkill! However, now that we can add 2 numbers, 
we can choose to call the function with arrays instead:

.. code-block:: python

    ## main.py

    #.... init here ....

    # Create a couple of buffers with 1,000,000 random floats in
    a = np.random.rand(1000000)
    b = np.random.rand(1000000)

    # Call our function and ask for a numpy array back (the default would be a buffer)
    result = module.add(a, b, return='numpy')

    # Print the first 10
    print(result[:10])



